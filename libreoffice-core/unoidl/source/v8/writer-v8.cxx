#include "rtl/ustrbuf.hxx"
#include "writer.hxx"
#include <iostream>

namespace writer {

OUString translateNamespace(OUString const& name) {
    return "::" + name.replaceFirst("com.sun.star.", "css.").replaceAll(".", "::");
}

void V8Writer::writeName(OUString const& name) { out(translateNamespace(name)); }

OUString V8Writer::translateSimpleType(OUString const& name) {
    if (name == "void")
        return "void";
    if (name == "boolean")
        return "sal_Bool";
    if (name == "byte")
        return "sal_Int8";
    if (name == "short")
        return "sal_Int16";
    if (name == "unsigned short")
        return "sal_uInt16";
    if (name == "long")
        return "sal_Int32";
    if (name == "unsigned long")
        return "sal_uInt32";
    if (name == "hyper")
        return "sal_Int64";
    if (name == "unsigned hyper")
        return "sal_uInt64";
    if (name == "float")
        return "float";
    if (name == "double")
        return "double";
    if (name == "char")
        return "sal_Unicode";
    if (name == "string")
        return "rtl_uString*";
    if (name == "type")
        return "typelib_TypeDescriptionReference*";
    if (name == "any")
        return "uno_Any";
    return name;
}

void V8Writer::writeInterfaceMethodsDeclaration(unoidl::InterfaceTypeEntity* entity,
                                                std::unordered_set<int>& declared) {
    for (auto& i : entity->getDirectMethods()) {
        if (shouldSkipMethod(i) || declared.find(i.name.hashCode()) != declared.end())
            continue;
        declared.emplace(i.name.hashCode());

        if (i.returnType == "void")
            out("void ");
        else
            out("v8::Local<v8::Value> ");

        out(i.name + "(v8::Isolate* isolate");
        for (auto& a : i.parameters) {
            out(", v8::Local<v8::Value> v8_" + a.name);
        }
        out(");\n");
    }
    for (auto& i : entity->getDirectMandatoryBases()) {
        // acquire/release are handled on object create/destroy
        if (i.name == "com.sun.star.uno.XInterface")
            continue;

        auto* base_ent = static_cast<unoidl::InterfaceTypeEntity*>(entities_[i.name]->entity.get());
        writeInterfaceMethodsDeclaration(base_ent, declared);
    }
}

void V8Writer::writeInterfaceDeclaration(OUString const& name,
                                         unoidl::InterfaceTypeEntity* entity) {
    out("class " + cName(name) + " : public gin::Wrappable<" + cName(name) + "> {\n");
    out("public:\n");

    out(cName(name) + "(const " + cName(name) + "&) = delete;\n");
    out(cName(name) + "& operator=(const " + cName(name) + "&) = delete;\n");
    out("void* Get() { return inst_; }\n");

    out("static gin::Handle<" + cName(name) + "> Create(v8::Isolate* isolate, void *inst);\n");

    out("static inline gin::WrapperInfo kWrapperInfo = {gin::kEmbedderNativeGin};\n");
    out("gin::ObjectTemplateBuilder GetObjectTemplateBuilder(v8::Isolate* isolate) override;\n");

    out("const char* GetTypeName() override {\n");
    out("return \"" + simplifyNamespace(name) + "\";\n");
    out("}\n");

    out("protected:\n");
    out(cName(name) + "() : inst_(nullptr) {}\n");
    out("~" + cName(name) + "();\n");

    out("private:\n");
    out("void* inst_;\n");
    std::unordered_set<int> declared{};
    writeInterfaceMethodsDeclaration(entity, declared);
    out("v8::Local<v8::Value> As(v8::Isolate* isolate, std::string typeName);\n");

    out("};\n");
}

void V8Writer::writeStructDeclaration(OUString const& name) {
    out("struct " + cStructName(name) + " from_v8_" + cName(name)
        + "(v8::Isolate *isolate, v8::Local<v8::Value> val);\n");
    out("v8::Local<v8::Value> to_v8_" + cName(name) + "(v8::Isolate *isolate, struct "
        + cStructName(name) + "& val);\n");
}

void V8Writer::writeHeaderIncludes() {
    out(R"(// THIS FILE IS AUTOMATICALLY GENERATED BY writer-v8.cxx - DO NOT EDIT!
/*
 * This file is part of the LibreOffice project.
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/.
 */

#pragma once

#include <tuple>
#include <vector>
#include "v8/include/v8-isolate.h"
#include "v8/include/v8-local-handle.h"
#include "v8/include/v8-primitive.h"
#include "v8/include/v8-object.h"
#include "v8/include/v8-exception.h"
#include "gin/wrappable.h"
#include "gin/per_isolate_data.h"
#include "LibreOfficeKit/UnoV8.h"
#include "office/office_client.h"
    )");
}

void V8Writer::writeClassIncludes() {
    out(R"(// THIS FILE IS AUTOMATICALLY GENERATED BY writer-v8.cxx - DO NOT EDIT!
/*
 * This file is part of the LibreOffice project.
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/.
 */

#include "unov8.hxx"
    )");
}

void V8Writer::writeDeclarations() {
    std::map<OUString, unoidl::InterfaceTypeEntity*> interfaces;
    std::map<OUString, unoidl::PlainStructTypeEntity*> structs;
    for (const auto& i : sorted_) {
        std::map<OUString, writer::Entity*>::iterator j(entities_.find(i));
        // skip irrelevant entities and those without bindings in JS/C++
        if (j == entities_.end() || !j->second->relevant)
            continue;

        switch (j->second->entity->getSort()) {
            case unoidl::Entity::SORT_INTERFACE_TYPE:
                interfaces.emplace(
                    j->first, static_cast<unoidl::InterfaceTypeEntity*>(j->second->entity.get()));
                break;
            case unoidl::Entity::SORT_PLAIN_STRUCT_TYPE:
                structs.emplace(
                    j->first, static_cast<unoidl::PlainStructTypeEntity*>(j->second->entity.get()));
                break;
            default:
                continue;
        }
    }

    out("namespace unoclass {\n");
    out("void MaybeThrowErr(v8::Isolate* isolate, rtl_uString* err);\n");

    for (auto& i : interfaces) {
        writeInterfaceDeclaration(i.first, i.second);
    }
    out("}\n");

    out("namespace convert {\n");
    for (auto& i : structs) {
        writeStructDeclaration(i.first);
    }

    out(R"(
uno_Sequence* Sequence(v8::Isolate* isolate, v8::Local<v8::Value> val, typelib_TypeDescriptionReference *typeRef);
v8::Local<v8::Value> Sequence(v8::Isolate* isolate, uno_Sequence* val, typelib_TypeDescriptionReference *typeRef);
v8::Local<v8::Value> AnyStructValue(v8::Isolate* isolate, void* val, rtl_uString* typeName);
void AnyStructValue(v8::Isolate* isolate, v8::Local<v8::Value> val, void* out_val, unsigned int type_id);
v8::Local<v8::Value> AnyInterfaceValue(v8::Isolate* isolate, void* const* val, rtl_uString* typeName);
v8::Local<v8::Value> AnyInterfaceValue_(v8::Isolate* isolate, void* const* val, std::string_view typeName);
v8::Local<v8::Value> AnyValue(v8::Isolate* isolate, void* val, typelib_TypeClass typeClass, rtl_uString* typeName);
void AnySimpleValue(v8::Isolate* isolate, v8::Local<v8::Value> val, void* out_val, typelib_TypeClass typeClass);
v8::Local<v8::Value> Any(v8::Isolate* isolate, uno_Any* val);
void Any(v8::Isolate* isolate, v8::Local<v8::Value> val, uno_Any* dest);
v8::Local<v8::Value> As(v8::Isolate* isolate, void* inst, std::string_view typeName);
uno_Sequence* PropertyValueSequence(v8::Isolate* isolate, v8::Local<v8::Value> val);
    )");

    out("}\n");
}

void V8Writer::writeSimpleTypeConverter() {
    out(R"(
namespace unoclass {

void MaybeThrowErr(v8::Isolate* isolate, rtl_uString* err) {
if (err == nullptr) return;
auto v8_err = v8::String::NewFromTwoByte(isolate, (uint16_t*)(err->buffer), v8::NewStringType::kNormal, err->length).ToLocalChecked();
electron::office::OfficeClient::GetUnoV8().rtl.uString_release(err);
isolate->ThrowException(v8::Exception::Error(v8_err));
// isolate->TerminateExecution();
}

class Type : public gin::Wrappable<Type> {
    public:
        Type(const Type&) = delete;
        Type& operator=(const Type&) = delete;

        static inline gin::WrapperInfo kWrapperInfo = {gin::kEmbedderNativeGin};

        typelib_TypeDescriptionReference* Get() { return type_; }

        static gin::Handle<Type> Create(v8::Isolate* isolate, typelib_TypeDescriptionReference* type) {
            auto *t = new Type();
            electron::office::OfficeClient::GetUnoV8().type.acquire(type);
            t->type_ = type;
            return CreateHandle(isolate, t);
        }

    protected:
        Type() : type_(nullptr) {}
        ~Type() {
            electron::office::OfficeClient::GetUnoV8().type.release(type_);
        };

    private:
       typelib_TypeDescriptionReference* type_;
};
}

namespace convert {

void ThrowTypeError(v8::Isolate* isolate, const char* message) {
    isolate->ThrowException(v8::Exception::Error(gin::StringToV8(isolate, message)));
    // isolate->TerminateExecution();
}

sal_Bool Bool(v8::Isolate* isolate, v8::Local<v8::Value> val) {
    if (!val->IsBoolean()) {
        ThrowTypeError(isolate, "unexpected type, expected bool");
        return 0;
    }
    return val->IsTrue() ? sal_True : sal_False;
}

v8::Local<v8::Value> Bool(v8::Isolate* isolate, sal_Bool val) {
    return v8::Boolean::New(isolate, val == sal_True).As<v8::Value>();;
}

sal_Int8 Byte(v8::Isolate* isolate, v8::Local<v8::Value> val) {
    if (!val->IsInt32()) {
        ThrowTypeError(isolate, "unexpected type, expected integer");
        return 0;
    }
    return static_cast<sal_Int8>(val.As<v8::Int32>()->Value());
}

v8::Local<v8::Value> Byte(v8::Isolate* isolate, sal_Int8 val) {
    return v8::Integer::New(isolate, val).As<v8::Value>();
}

sal_Int16 Short(v8::Isolate* isolate, v8::Local<v8::Value> val) {
    if (!val->IsInt32()) {
        ThrowTypeError(isolate, "unexpected type, expected integer");
        return 0;
    }
    return static_cast<sal_Int16>(val.As<v8::Int32>()->Value());
}

v8::Local<v8::Value> Short(v8::Isolate* isolate, sal_Int16 val) {
    return v8::Integer::New(isolate, val).As<v8::Value>();
}

sal_Int32 Long(v8::Isolate* isolate, v8::Local<v8::Value> val) {
    if (!val->IsInt32()) {
        ThrowTypeError(isolate, "unexpected type, expected integer");
        return 0;
    }
    return static_cast<sal_Int32>(val.As<v8::Int32>()->Value());
}

v8::Local<v8::Value> Long(v8::Isolate* isolate, sal_Int32 val) {
    return v8::Integer::New(isolate, val).As<v8::Value>();
}

sal_uInt32 UShort(v8::Isolate* isolate, v8::Local<v8::Value> val) {
    if (!val->IsInt32()) {
        ThrowTypeError(isolate, "unexpected type, expected unsigned integer");
        return 0;
    }
    return static_cast<sal_uInt16>(val.As<v8::Uint32>()->Value());
}

v8::Local<v8::Value> UShort(v8::Isolate* isolate, sal_uInt32 val) {
    return v8::Integer::NewFromUnsigned(isolate, val).As<v8::Value>();
}

sal_uInt32 ULong(v8::Isolate* isolate, v8::Local<v8::Value> val) {
    if (!val->IsInt32()) {
        ThrowTypeError(isolate, "unexpected type, expected unsigned integer");
        return 0;
    }
    return static_cast<sal_uInt32>(val.As<v8::Uint32>()->Value());
}

v8::Local<v8::Value> ULong(v8::Isolate* isolate, sal_uInt32 val) {
    return v8::Integer::NewFromUnsigned(isolate, val).As<v8::Value>();
}

float Float(v8::Isolate* isolate, v8::Local<v8::Value> val) {
    if (!val->IsNumber()) {
        ThrowTypeError(isolate, "unexpected type, expected float");
        return 0;
    }
    return static_cast<float>(val.As<v8::Number>()->Value());
}

v8::Local<v8::Value> Float(v8::Isolate* isolate, float val) {
    return v8::Number::New(isolate, val).As<v8::Value>();
}

double Double(v8::Isolate* isolate, v8::Local<v8::Value> val) {
    if (!val->IsNumber()) {
        ThrowTypeError(isolate, "unexpected type, expected double");
        return 0;
    }
    return static_cast<double>(val.As<v8::Number>()->Value());
}

v8::Local<v8::Value> Double(v8::Isolate* isolate, double val) {
    return v8::Number::New(isolate, val).As<v8::Value>();
}

sal_Int64 Hyper(v8::Isolate* isolate, v8::Local<v8::Value> val) {
    if (!val->IsBigInt()) {
        ThrowTypeError(isolate, "unexpected type, expected BigInt");
        return 0;
    }
    return static_cast<sal_Int64>(val.As<v8::BigInt>()->Int64Value());
}

v8::Local<v8::Value> Hyper(v8::Isolate* isolate, sal_Int64 val) {
    return v8::BigInt::New(isolate, val).As<v8::Value>();
}

sal_uInt64 UHyper(v8::Isolate* isolate, v8::Local<v8::Value> val) {
    if (!val->IsBigInt()) {
        ThrowTypeError(isolate, "unexpected type, expected BigInt");
        return 0;
    }
    return static_cast<sal_uInt64>(val.As<v8::BigInt>()->Uint64Value());
}

v8::Local<v8::Value> UHyper(v8::Isolate* isolate, sal_uInt64 val) {
    return v8::BigInt::NewFromUnsigned(isolate, val).As<v8::Value>();
}

sal_Unicode Char(v8::Isolate* isolate, v8::Local<v8::Value> val) {
    if (!val->IsString()) {
        ThrowTypeError(isolate, "unexpected type, expected string");
        return 0;
    }
    v8::Local<v8::String> str = v8::Local<v8::String>::Cast(val);
    sal_Unicode result = 0;
    str->Write(isolate, (uint16_t*)(&result), 0, 1);
    return result;
}

v8::Local<v8::Value> Char(v8::Isolate* isolate, sal_Unicode val) {
    return v8::String::NewFromTwoByte(isolate, (uint16_t*)(&val), v8::NewStringType::kNormal, 1).ToLocalChecked().As<v8::Value>();
}

rtl_uString* String(v8::Isolate* isolate, v8::Local<v8::Value> val) {
    if (!val->IsString()) {
        ThrowTypeError(isolate, "unexpected type, expected string");
        return nullptr;
    }
    v8::Local<v8::String> str = v8::Local<v8::String>::Cast(val);
    rtl_uString* result = electron::office::OfficeClient::GetUnoV8().rtl.uString_alloc(str->Length());
    if (!result) {
        ThrowTypeError(isolate, "unable to allocate UNO UString string");
        return nullptr;
    }

    str->Write(isolate, (uint16_t*)(result->buffer), 0, str->Length());
    return result;
}

v8::Local<v8::Value> String(v8::Isolate* isolate, rtl_uString* val) {
    auto result = v8::String::NewFromTwoByte(isolate, (uint16_t*)(val->buffer), v8::NewStringType::kNormal, val->length).ToLocalChecked().As<v8::Value>();
    electron::office::OfficeClient::GetUnoV8().rtl.uString_release(val);
    return result;
}

}
)");
}

namespace {
// handles all but Void/Type/Any
OUString translateSimpleTypeHandler(OUString const& name) {
    if (name == "boolean")
        return "Bool";
    if (name == "byte")
        return "Byte";
    if (name == "short")
        return "Short";
    if (name == "unsigned short")
        return "UShort";
    if (name == "long")
        return "Long";
    if (name == "unsigned long")
        return "ULong";
    if (name == "hyper")
        return "Hyper";
    if (name == "unsigned hyper")
        return "UHyper";
    if (name == "float")
        return "Float";
    if (name == "double")
        return "Double";
    if (name == "char")
        return "Char";
    if (name == "string")
        return "String";
    return "";
}

OUString translateSimpleTypeAsTypeClassPostfix(OUString const& name) {
    if (name == "void")
        return "VOID";
    if (name == "any")
        return "ANY";
    if (name == "type")
        return "TYPE";
    if (name == "boolean")
        return "BOOLEAN";
    if (name == "byte")
        return "BYTE";
    if (name == "short")
        return "SHORT";
    if (name == "unsigned short")
        return "UNSIGNED_SHORT";
    if (name == "long")
        return "LONG";
    if (name == "unsigned long")
        return "UNSIGNED_LONG";
    if (name == "hyper")
        return "HYPER";
    if (name == "unsigned hyper")
        return "UNSIGNED_HYPER";
    if (name == "float")
        return "FLOAT";
    if (name == "double")
        return "DOUBLE";
    if (name == "char")
        return "CHAR";
    if (name == "string")
        return "STRING";
    return "";
}
}

void V8Writer::writeAnyTypeConverter() {
    std::map<OUString, unoidl::InterfaceTypeEntity*> interfaces;
    std::map<OUString, unoidl::PlainStructTypeEntity*> structs;
    for (const auto& i : sorted_) {
        std::map<OUString, writer::Entity*>::iterator j(entities_.find(i));
        // skip irrelevant entities and those without bindings in JS/C++
        if (j == entities_.end() || !j->second->relevant)
            continue;

        switch (j->second->entity->getSort()) {
            case unoidl::Entity::SORT_INTERFACE_TYPE:
                interfaces.emplace(
                    j->first, static_cast<unoidl::InterfaceTypeEntity*>(j->second->entity.get()));
                break;
            case unoidl::Entity::SORT_PLAIN_STRUCT_TYPE:
                structs.emplace(
                    j->first, static_cast<unoidl::PlainStructTypeEntity*>(j->second->entity.get()));
                break;
            default:
                continue;
        }
    }

    out(R"(
namespace convert {

constexpr uint32_t hash(const std::string_view key) noexcept {
  uint32_t hash = 5381;
  for (const auto &e : key)
    hash = ((hash << 5) + hash) + e;
  return hash;
}

void Any(v8::Isolate* isolate, v8::Local<v8::Value> val, uno_Any* dest) {
    auto& api = electron::office::OfficeClient::GetUnoV8();
    void *c_value = nullptr;
    typelib_TypeDescriptionReference* c_type = nullptr;
    typelib_TypeClass typeClass = typelib_TypeClass_VOID;
    if (val->IsNullOrUndefined()) {
        c_type = *api.type.getByTypeClass(typeClass);
    } else if (val->IsString()) {
        typeClass = typelib_TypeClass_STRING;
        c_type = *api.type.getByTypeClass(typeClass);
        c_value = new (rtl_uString*);
        *static_cast<rtl_uString**>(c_value) = String(isolate, val);
    } else if (val->IsBoolean()) {
        typeClass = typelib_TypeClass_BOOLEAN;
        c_type = *api.type.getByTypeClass(typeClass);
        c_value = new sal_Bool;
        *static_cast<sal_Bool*>(c_value) = val->IsTrue() ? sal_True : sal_False;
    } else if (val->IsUint32()) {
        typeClass = typelib_TypeClass_UNSIGNED_LONG;
        c_type = *api.type.getByTypeClass(typeClass);
        c_value = new sal_uInt32;
        *static_cast<sal_uInt32*>(c_value) = ULong(isolate, val);
    } else if (val->IsInt32()) {
        typeClass = typelib_TypeClass_LONG;
        c_type = *api.type.getByTypeClass(typeClass);
        c_value = new sal_Int32;
        *static_cast<sal_Int32*>(c_value) = Long(isolate, val);
    } else if (val->IsNumber()) {
        typeClass = typelib_TypeClass_DOUBLE;
        c_type = *api.type.getByTypeClass(typeClass);
        c_value = new double;
        *static_cast<double*>(c_value) = Double(isolate, val);
    } else if (val->IsBigInt()) {
        typeClass = typelib_TypeClass_HYPER;
        c_type = *api.type.getByTypeClass(typeClass);
        c_value = new sal_Int64;
        *static_cast<sal_Int64*>(c_value) = Hyper(isolate, val);
    } else if (val->IsArray()) {
        ThrowTypeError(isolate, "TODO: support passing arrays as an Any<Sequence<T>>");
    } else if (val->IsObject()) {
        v8::Local<v8::Object> obj = v8::Local<v8::Object>::Cast(val);
        gin::WrapperInfo* info = gin::WrapperInfo::From(obj);

        // If this fails, the object is not managed by Gin
        if (!info && obj->InternalFieldCount() != 1) {
            ThrowTypeError(isolate, "unable to convert value to uno_Any, invalid object: expected an UNO interface, TODO: support struct");
            return;
        }
        typeClass = typelib_TypeClass_INTERFACE;
        c_value = new (void**);
)");

    for (auto& i : interfaces) {
        out("if (info == &unoclass::" + cName(i.first) + "::kWrapperInfo) {\n");
        out("*static_cast<void**>(c_value) = static_cast<unoclass::" + cName(i.first)
            + "*>(obj->GetAlignedPointerFromInternalField(gin::kEncodedValueIndex))->Get();\n");
        out("c_type = "
            "electron::office::OfficeClient::GetUnoV8().type.interfaceTypeFromId(convert::hash(\""
            + simplifyNamespace(i.first) + "\"));\n");
        out("} else ");
    }
    out(R"(
        {
            ThrowTypeError(isolate, "unable to convert value to uno_Any, unexpected interface type");
            return;
        }
    )");

    out(R"(
    } else {
        ThrowTypeError(isolate, "unable to convert value to uno_Any, unexpected type");
        return;
    }
    electron::office::OfficeClient::GetUnoV8().any.construct(dest, c_value, c_type);
    switch (typeClass) {
        case typelib_TypeClass_BOOLEAN:
            delete static_cast<sal_Bool*>(c_value);
            break;
        case typelib_TypeClass_UNSIGNED_LONG:
            delete static_cast<sal_uInt32*>(c_value);
            break;
        case typelib_TypeClass_LONG:
            delete static_cast<sal_Int32*>(c_value);
            break;
        case typelib_TypeClass_DOUBLE:
            delete static_cast<double*>(c_value);
            break;
        case typelib_TypeClass_HYPER:
            delete static_cast<sal_Int64*>(c_value);
            break;
        case typelib_TypeClass_STRING:
            delete static_cast<rtl_uString**>(c_value);
            break;
        case typelib_TypeClass_INTERFACE:
            delete static_cast<void**>(c_value);
            break;
        default: break;
    }
}

v8::Local<v8::Value> AnyStructValue(v8::Isolate* isolate, void* val, rtl_uString* typeName) {
    auto& unov8_ = electron::office::OfficeClient::GetUnoV8();
    rtl_String* utf8Name = unov8_.rtl.uStringToUtf8(typeName);
    switch (hash(std::string_view(utf8Name->buffer, utf8Name->length))) {
)");

    for (auto& i : structs) {
        out("case hash(\"" + i.first + "\"): return convert::to_v8_" + cName(i.first)
            + "(isolate, *static_cast<" + cStructName(i.first) + "*>(val));\n");
    }

    out(R"(default: return v8::Undefined(isolate);
    }
}

void AnyStructValue(v8::Isolate* isolate, v8::Local<v8::Value> val, void* out_val, unsigned int type_id) {
    switch (type_id) {
)");

    for (auto& i : structs) {
        out("case hash(\"" + i.first + "\"): *static_cast<" + cStructName(i.first)
            + "*>(out_val) = convert::from_v8_" + cName(i.first) + "(isolate, val);\n");
        out("break;\n");
    }

    out(R"(default: break;
    }
}

v8::Local<v8::Value> AnyInterfaceValue_(v8::Isolate* isolate, void* const* val, std::string_view typeName) {
    switch (hash(typeName)) {
)");

    for (auto& i : interfaces) {
        out("case hash(\"" + i.first + "\"): return unoclass::" + cName(i.first)
            + "::Create(isolate, *val).ToV8();\n");
    }

    out(R"(default: return v8::Undefined(isolate);
    }
}

v8::Local<v8::Value> AnyInterfaceValueWithSimplifiedType(v8::Isolate* isolate, void * val, std::string_view typeName) {
    switch (hash(typeName)) {
)");

    for (auto& i : interfaces) {
        out("case hash(\"" + simplifyNamespace(i.first) + "\"): return unoclass::" + cName(i.first)
            + "::Create(isolate, val).ToV8();\n");
    }

    out(R"(default: return v8::Undefined(isolate);
    }
}

v8::Local<v8::Value> AnyInterfaceValue(v8::Isolate* isolate, void* const* val, rtl_uString* typeName) {
    auto& unov8_ = electron::office::OfficeClient::GetUnoV8();
    rtl_String* utf8Name = unov8_.rtl.uStringToUtf8(typeName);
    return AnyInterfaceValue_(isolate, val, std::string_view(utf8Name->buffer, utf8Name->length));
}

namespace {
bool IsValueClassType(v8::Isolate* isolate, v8::Local<v8::Value> val, typelib_TypeClass typeClass) {
    switch (typeClass) {
        case typelib_TypeClass_VOID: return val->IsNullOrUndefined();
        case typelib_TypeClass_ANY: return true;
        case typelib_TypeClass_TYPE: return val->IsObject() && gin::WrapperInfo::From(v8::Local<v8::Object>::Cast(val)) == &unoclass::Type::kWrapperInfo;
        case typelib_TypeClass_BOOLEAN: return val->IsBoolean();
        case typelib_TypeClass_BYTE: return val->IsString();
        case typelib_TypeClass_SHORT: return val->IsInt32();
        case typelib_TypeClass_UNSIGNED_SHORT: return val->IsUint32();
        case typelib_TypeClass_LONG: return val->IsInt32();
        case typelib_TypeClass_UNSIGNED_LONG: return val->IsUint32();
        case typelib_TypeClass_HYPER: return val->IsBigInt();
        case typelib_TypeClass_UNSIGNED_HYPER: return val->IsBigInt();
        case typelib_TypeClass_FLOAT: return val->IsNumber();
        case typelib_TypeClass_DOUBLE: return val->IsNumber();
        case typelib_TypeClass_CHAR: return val->IsString();
        case typelib_TypeClass_STRING: return val->IsString();
        case typelib_TypeClass_SEQUENCE: return val->IsArray();
        case typelib_TypeClass_INTERFACE: return val->IsObject() && gin::WrapperInfo::From(v8::Local<v8::Object>::Cast(val)) != nullptr;
        default: return false;
    }
}
}

uno_Sequence* Sequence(v8::Isolate* isolate, v8::Local<v8::Value> val, typelib_TypeDescriptionReference* elTypeRef) {
    auto& unov8_ = electron::office::OfficeClient::GetUnoV8();
    if (!val->IsArray()) {
        convert::ThrowTypeError(isolate, "Attempted to convert a non-array into a UNO sequence");
        return nullptr;
    }
    v8::Local<v8::Array> array(v8::Local<v8::Array>::Cast(val));
    unsigned int length = array->Length();
    typelib_TypeDescriptionReference* typeRef = unov8_.type.sequenceType(elTypeRef);
    typelib_TypeDescription* elTypeDesc = nullptr;
    unov8_.type.dangerGet(&elTypeDesc, elTypeRef);
    int elSize = elTypeDesc->nSize;
    unov8_.type.dangerRelease(elTypeDesc);
    typelib_TypeClass typeClass = elTypeRef->eTypeClass;
    if (typeClass == typelib_TypeClass_INTERFACE || typeClass == typelib_TypeClass_STRUCT) {
        unov8_.type.release(typeRef);
        convert::ThrowTypeError(isolate, "Converting an array to sequences of interfaces or structs at runtime is not supported");
        return nullptr;
    }

    char *elements = new char[elSize * length];
    for (unsigned int i = 0; i < length; ++i) {
        v8::Local<v8::Value> v8_item;
        if (!array->Get(isolate->GetCurrentContext(), i).ToLocal(&v8_item) || !IsValueClassType(isolate, v8_item, typeClass)) {
            delete[] elements;
            unov8_.type.release(typeRef);
            convert::ThrowTypeError(isolate, "Unable to construct sequence from an array, elements must all be the same type in the sequence");
            return nullptr;
        }
        void *el = elements + elSize * i;
        AnySimpleValue(isolate, v8_item, el, typeClass);
    }
    uno_Sequence* result = unov8_.sequence.construct(typeRef, elements, length);

    delete[] elements;
    unov8_.type.release(typeRef);
    return result;
}

uno_Sequence* PropertyValueSequence(v8::Isolate* isolate, v8::Local<v8::Value> val) {
    auto& unov8_ = electron::office::OfficeClient::GetUnoV8();
    if (!val->IsObject()) {
        convert::ThrowTypeError(isolate, "Attempted to convert a non-array into a UNO sequence of property values");
        return nullptr;
    }
    v8::Local<v8::Object> v8_object = val.As<v8::Object>();
    typelib_TypeDescriptionReference* elTypeRef = unov8_.type.structType(convert::hash("beans.PropertyValue"));
    typelib_TypeDescriptionReference* typeRef = unov8_.type.sequenceType(elTypeRef);
    typelib_TypeDescription* elTypeDesc = nullptr;
    unov8_.type.dangerGet(&elTypeDesc, elTypeRef);
    int elSize = elTypeDesc->nSize;
    unov8_.type.dangerRelease(elTypeDesc);

    int valid_length = 0;

    v8::Local<v8::Context> context = isolate->GetCurrentContext();
    v8::Local<v8::Array> property_names(v8_object->GetOwnPropertyNames(context).ToLocalChecked());

    char *elements = new char[elSize * property_names->Length()];
    for (uint32_t i = 0; i < property_names->Length(); ++i) {
        v8::Local<v8::Value> key(property_names->Get(context, i).ToLocalChecked());

        if (!key->IsString()) {
            continue;
        }

        v8::Local<v8::String> key_string = key->ToString(context).ToLocalChecked();
        // Skip all callbacks
        if (v8_object->HasRealNamedCallbackProperty(context, key_string).ToChecked()) {
            continue;
        }

        v8::Local<v8::Value> child_v8;
        if (!v8_object->Get(context, key).ToLocal(&child_v8))
            continue;

        v8::String::Value name(isolate, key_string);

        void *el = elements + elSize * valid_length;
        uno_Any* any_val = unov8_.sequence.writePropertyValue(*name, name.length(), el);
        // prevents child_v8's internal value from being optimized-out by the compiler, TODO: figure out why it is optimzed-out?
        std::ignore = child_v8->IsNullOrUndefined() ||
            child_v8->IsString() ||
            child_v8->IsBoolean() ||
            child_v8->IsNumber() ||
            child_v8->IsArray() ||
            child_v8->IsObject();
        Any(isolate, child_v8, any_val);

        valid_length++;
    }
    uno_Sequence* result = unov8_.sequence.construct(typeRef, elements, valid_length);
    delete[] elements;
    unov8_.type.release(typeRef);
    return result;
}

v8::Local<v8::Value> Sequence(v8::Isolate* isolate, uno_Sequence* val, typelib_TypeDescriptionReference *typeRef) {
    auto& unov8_ = electron::office::OfficeClient::GetUnoV8();
    int len = val->nElements;
    v8::Local<v8::Array> result = v8::Array::New(isolate, len);

    if (len == 0) return result;

    typelib_TypeDescription *typeDesc = nullptr;
    unov8_.type.dangerGet(&typeDesc, typeRef);
    if (!typeDesc)
        return v8::Undefined(isolate);

    typelib_TypeDescriptionReference* elTypeRef = reinterpret_cast<typelib_IndirectTypeDescription*>(typeDesc)->pType;

    typelib_TypeDescription *elTypeDesc = nullptr;
    unov8_.type.dangerGet(&elTypeDesc, elTypeRef);

    int elSize = elTypeDesc->nSize;

    v8::Local<v8::Context> context = isolate->GetCurrentContext();
    char *elements = val->elements;

    for (int i = 0; i < len; ++i) {
        void *el = static_cast<void*>(elements + (elSize * i));
        result->CreateDataProperty(
            context, i, elTypeRef->eTypeClass == typelib_TypeClass_SEQUENCE ?
                Sequence(isolate, static_cast<uno_Sequence*>(el), elTypeRef) : AnyValue(isolate, &el, elTypeRef->eTypeClass, elTypeRef->pTypeName)
            ).ToChecked();
    }

    unov8_.type.dangerRelease(elTypeDesc);
    unov8_.type.dangerRelease(typeDesc);
    return result.As<v8::Value>();
}

void AnySimpleValue(v8::Isolate* isolate, v8::Local<v8::Value> val, void* out_val, typelib_TypeClass typeClass) {
    switch(typeClass) {
        case typelib_TypeClass_ANY:
            Any(isolate, val, static_cast<uno_Any*>(out_val));
            break;
        case typelib_TypeClass_BOOLEAN:
            *(static_cast<sal_Bool*>(out_val)) = Bool(isolate, val);
            break;
        case typelib_TypeClass_STRING:
            *(static_cast<rtl_uString**>(out_val)) = String(isolate, val);
            break;
        case typelib_TypeClass_BYTE:
            *(static_cast<sal_Int8*>(out_val)) = Byte(isolate, val);
            break;
        case typelib_TypeClass_SHORT:
            *static_cast<sal_Int16*>(out_val) = Short(isolate, val);
            break;
        case typelib_TypeClass_UNSIGNED_SHORT:
            *static_cast<sal_uInt16*>(out_val) = UShort(isolate, val);
            break;
        case typelib_TypeClass_LONG:
        case typelib_TypeClass_ENUM:
            *static_cast<sal_Int32*>(out_val) = Long(isolate, val);
            break;
        case typelib_TypeClass_UNSIGNED_LONG:
            *static_cast<sal_uInt32*>(out_val) = ULong(isolate, val);
            break;
        case typelib_TypeClass_HYPER:
            *static_cast<sal_Int64*>(out_val) = Hyper(isolate, val);
            break;
        case typelib_TypeClass_UNSIGNED_HYPER:
            *static_cast<sal_uInt64*>(out_val) = UHyper(isolate, val);
            break;
        case typelib_TypeClass_FLOAT:
            *static_cast<float*>(out_val) = Float(isolate, val);
            break;
        case typelib_TypeClass_DOUBLE:
            *static_cast<double*>(out_val) = Double(isolate, val);
            break;
        case typelib_TypeClass_CHAR:
            *static_cast<sal_Unicode*>(out_val) = Char(isolate, val);
            break;
        case typelib_TypeClass_TYPE: {
            v8::Local<v8::Object> obj = v8::Local<v8::Object>::Cast(val);
            gin::WrapperInfo* info = gin::WrapperInfo::From(obj);
            *static_cast<typelib_TypeDescriptionReference **>(out_val) =
                info == &unoclass::Type::kWrapperInfo ?
                    static_cast<unoclass::Type*>(obj->GetAlignedPointerFromInternalField(gin::kEncodedValueIndex))->Get() : nullptr;
            break;
        }
        default: break;
    }
}

v8::Local<v8::Value> AnyValue(v8::Isolate* isolate, void* val, typelib_TypeClass typeClass, rtl_uString* typeName) {
    switch(typeClass) {
        case typelib_TypeClass_ANY:
            return Any(isolate, *static_cast<uno_Any* const*>(val));
        case typelib_TypeClass_VOID:
            return v8::Null(isolate).As<v8::Value>();
        case typelib_TypeClass_BOOLEAN:
            return Bool(isolate, *static_cast<sal_Bool const*>(val));
        case typelib_TypeClass_STRING:
            return String(isolate, *static_cast<rtl_uString* const*>(val));
        case typelib_TypeClass_BYTE:
            return Byte(isolate, *static_cast<sal_Int8 const*>(val));
        case typelib_TypeClass_SHORT:
            return Short(isolate, *static_cast<sal_Int16 const*>(val));
        case typelib_TypeClass_UNSIGNED_SHORT:
            return UShort(isolate, *static_cast<sal_uInt16 const*>(val));
        case typelib_TypeClass_LONG:
        case typelib_TypeClass_ENUM:
            return Long(isolate, *static_cast<sal_Int32 const*>(val));
        case typelib_TypeClass_UNSIGNED_LONG:
            return ULong(isolate, *static_cast<sal_uInt32 const*>(val));
        case typelib_TypeClass_HYPER:
            return Hyper(isolate, *static_cast<sal_Int64 const*>(val));
        case typelib_TypeClass_UNSIGNED_HYPER:
            return UHyper(isolate, *static_cast<sal_uInt64 const*>(val));
        case typelib_TypeClass_FLOAT:
            return Float(isolate, *static_cast<float const*>(val));
        case typelib_TypeClass_DOUBLE:
            return Double(isolate, *static_cast<double const*>(val));
        case typelib_TypeClass_CHAR:
            return Char(isolate, *static_cast<sal_Unicode const*>(val));
        case typelib_TypeClass_TYPE:
            return unoclass::Type::Create(isolate, *static_cast<typelib_TypeDescriptionReference * const*>(val)).ToV8();
        case typelib_TypeClass_INTERFACE:
            return AnyInterfaceValue(isolate, static_cast<void* const*>(val), typeName);
        case typelib_TypeClass_STRUCT:
            return AnyStructValue(isolate, *static_cast<void* const*>(val), typeName);
        default: return v8::Undefined(isolate);
    }
}

v8::Local<v8::Value> Any(v8::Isolate* isolate, uno_Any* val) {
    if (val->pType->eTypeClass == typelib_TypeClass_SEQUENCE) {
        return Sequence(isolate, static_cast<uno_Sequence*>(val->pData), val->pType);
    }
    return AnyValue(isolate, val->pData, val->pType->eTypeClass, val->pType->pTypeName);
}

v8::Local<v8::Value> As(v8::Isolate* isolate, void* inst, std::string_view typeName) {
    if (!inst) return v8::Undefined(isolate);

    auto& unov8_ = electron::office::OfficeClient::GetUnoV8();
    typelib_TypeDescriptionReference* type_ref = unov8_.type.interfaceType(typeName.data(), typeName.length());
    if (!type_ref) return v8::Undefined(isolate);
    void *new_inst = unov8_.interface.queryInterface(inst, type_ref);
    if (!new_inst) {
        return v8::Undefined(isolate);
    }

    return convert::AnyInterfaceValueWithSimplifiedType(isolate, new_inst, typeName);
}
}
)");
}

void V8Writer::writeEntity(const OUString& name) {
    std::map<OUString, Entity*>::iterator i(entities_.find(name));
    if (i == entities_.end() || !i->second->relevant)
        return;

    assert(i->second.written != Entity::Written::DEFINITION);
    i->second->written = Entity::Written::DEFINITION;

    for (auto& j : i->second->dependencies) {
        std::map<OUString, Entity*>::iterator k(entities_.find(j));
        if (k == entities_.end()) {
            continue;
        }

        if (k->second->entity->getSort() != unoidl::Entity::SORT_EXCEPTION_TYPE) {
            k->second->written = Entity::Written::DECLARATION;

            writeInterfaceDependency(
                name, j,
                static_cast<unoidl::PublishableEntity*>(k->second->entity.get())->isPublished());
        }
    }
    for (auto& j : i->second->interfaceDependencies) {
        std::map<OUString, Entity*>::iterator k(entities_.find(j));
        if (k != entities_.end()) {
            k->second->written = Entity::Written::DECLARATION;

            if (k->second->entity->getSort() != unoidl::Entity::SORT_INTERFACE_TYPE) {
                std::cerr << "Entity " << j << " should be an interface type" << std::endl;
                std::exit(EXIT_FAILURE);
            }

            writeInterfaceDependency(
                name, j,
                static_cast<unoidl::PublishableEntity*>(k->second->entity.get())->isPublished());
        } else {
            writeInterfaceDependency(name, j, false);
        }
    }
    rtl::Reference<unoidl::Entity> ent = i->second->entity;

    switch (ent->getSort()) {
        case unoidl::Entity::SORT_ENUM_TYPE: {
            enums_.emplace(name, static_cast<unoidl::EnumTypeEntity*>(ent.get()));
            break;
        }
        case unoidl::Entity::SORT_PLAIN_STRUCT_TYPE: {
            structs_.emplace(name, static_cast<unoidl::PlainStructTypeEntity*>(ent.get()));
            break;
        }
        case unoidl::Entity::SORT_INTERFACE_TYPE: {
            interfaces_.emplace(name, static_cast<unoidl::InterfaceTypeEntity*>(ent.get()));
            break;
        }
        case unoidl::Entity::SORT_CONSTANT_GROUP: {
            constgroups_.emplace(name, static_cast<unoidl::ConstantGroupEntity*>(ent.get()));
            break;
        }
        default:
            break;
    }
}

void V8Writer::writeOrganizedEntities() {
    out("namespace unoclass {\n");
    for (auto& j : interfaces_) {
        writeInterface(j.first, j.second);
    }
    out("}\n");

    out("namespace convert {\n");
    for (auto& j : structs_) {
        writePlainStruct(j.first, j.second);
    }
    out("}\n");

    out("namespace unoconst {\n");
    for (auto& j : constgroups_) {
        writeConstantGroup(j.first, j.second);
    }
    for (auto& j : enums_) {
        writeEnum(j.first, j.second);
    }
    out("}\n");
}

void V8Writer::writeType(OUString const& name) {
    std::size_t rank;
    std::vector<OUString> args;
    bool isEntity;
    OUString nucl(decomposeType(name, &rank, &args, &isEntity));

    if (rank > 0) {
        return out("uno_Sequence*");
    }
    if (!isEntity) {
        return out(translateSimpleType(nucl));
    }
    auto entity = entities_.find(nucl);
    if (entity == entities_.end()) {
        return out(nucl);
    }
    auto sort = entity->second->entity->getSort();
    switch (sort) {
        case unoidl::Entity::SORT_INTERFACE_TYPE:
            return out("void*");
        case unoidl::Entity::SORT_PLAIN_STRUCT_TYPE:
            return out("struct " + cStructName(nucl));
        case unoidl::Entity::SORT_TYPEDEF:
            return writeType(
                static_cast<unoidl::TypedefEntity*>(entity->second->entity.get())->getType());
        case unoidl::Entity::SORT_ENUM_TYPE:
            return out("unsigned int");
        default:
            break;
    }
}

void V8Writer::writeInterfaceDependency(OUString const& dependentName,
                                        OUString const& dependencyName, bool published) {
    // no-op
    (void)dependencyName;
    (void)dependentName;
    (void)published;
}

void V8Writer::writeEnum(OUString const& name, rtl::Reference<unoidl::EnumTypeEntity> entity) {
    out("v8::Local<v8::Object> init_" + cName(name)
        + "(v8::Isolate* isolate) {\n"
          "v8::Local<v8::Object> result = v8::Object::New(isolate);\n");
    for (auto& i : entity->getMembers()) {
        out("result->DefineOwnProperty(isolate->GetCurrentContext(), "
            "v8::String::NewFromUtf8Literal(isolate, \""
            + i.name + "\"), ");
        out("v8::Integer::NewFromUnsigned(isolate, " + OUString::number(i.value) + ")");
        out(", v8::ReadOnly).Check();\n");
    }
    out("return result;\n");
    out("}\n");
}

void V8Writer::writePlainStruct(OUString const& name,
                                rtl::Reference<unoidl::PlainStructTypeEntity> entity) {
    out("v8::Local<v8::Value> to_v8_" + cName(name) + "(v8::Isolate *isolate, struct "
        + cStructName(name) + "& val) {\n");
    auto base = entity->getDirectBase();
    if (base.isEmpty()) {
        out("v8::Local<v8::Object> obj = v8::Object::New(isolate);\n");
    } else {
        out("v8::Local<v8::Object> obj = v8::Local<v8::Object>::Cast(to_v8_" + cName(base)
            + "(isolate, val.base));\n");
    }

    std::size_t rank;
    std::vector<OUString> args;
    bool isEntity;
    bool has_unov8 = false;
    for (auto& m : entity->getDirectMembers()) {
        OUString nucl(decomposeType(resolveTypedef(m.type), &rank, &args, &isEntity));
        if (rank > 0) {
            if (!has_unov8) {
                out("auto& unov8_ = electron::office::OfficeClient::GetUnoV8();\n");
                has_unov8 = true;
            }
            out("{\n");
            out("typelib_TypeDescriptionReference* base_type = ");
            if (isEntity) {
                switch (entities_[nucl]->entity->getSort()) {
                    case unoidl::Entity::SORT_INTERFACE_TYPE:
                        out("unov8_.type.interfaceTypeFromId(hash(\"" + simplifyNamespace(nucl)
                            + "\"))");
                        break;
                    case unoidl::Entity::SORT_ENUM_TYPE:
                        out("unov8_.type.enumType(hash(\"" + simplifyNamespace(nucl) + "\"))");
                        break;
                    case unoidl::Entity::SORT_PLAIN_STRUCT_TYPE:
                        out("unov8_.type.structType(hash(\"" + simplifyNamespace(nucl) + "\"))");
                        break;
                    default:
                        break;
                }
            } else {
                out("*unov8_.type.getByTypeClass(typelib_TypeClass_"
                    + translateSimpleTypeAsTypeClassPostfix(nucl) + ")");
            }
            out(";\n");

            out("typelib_TypeDescriptionReference* seq_types[" + OUString::number(rank) + "];\n");
            for (size_t i = 0; i < rank; i++) {
                out("seq_types[" + OUString::number(i) + "] = unov8_.type.sequenceType(");
                if (i == 0)
                    out("base_type");
                else
                    out("seq_types[" + OUString::number(i - 1) + "]");
                out(");\n");
            }
        }

        out("obj->Set(isolate->GetCurrentContext(), v8::String::NewFromUtf8Literal(isolate, \""
            + m.name + "\"), ");
        if (rank > 0) {
            out("convert::Sequence(isolate, val." + m.name + ", seq_types["
                + OUString::number(rank - 1) + "])");
        } else if (isEntity) {
            switch (entities_[nucl]->entity->getSort()) {
                case unoidl::Entity::SORT_INTERFACE_TYPE:
                    out("unoclass::" + cName(nucl) + "::Create(isolate, val." + m.name
                        + ").ToV8()");
                    break;
                case unoidl::Entity::SORT_ENUM_TYPE:
                    out("convert::ULong(isolate, val." + m.name + ")");
                    break;
                case unoidl::Entity::SORT_PLAIN_STRUCT_TYPE:
                    out("to_v8_" + cName(nucl) + "(isolate, val." + m.name + ")");
                    break;
                default:
                    break;
            }
        } else if (nucl == "any") {
            out("convert::Any(isolate, &val." + m.name + ")");
        } else if (nucl == "type") {
            out("unoclass::Type::Create(isolate, val." + m.name + ").ToV8()");
        } else if (nucl == "void") {
            out("v8::Null(isolate)");
        } else {
            out("convert::" + translateSimpleTypeHandler(nucl) + "(isolate, val." + m.name + ")");
        }
        out(").Check();\n");

        if (rank > 0) {
            for (int i = (int)rank - 1; i >= 0; i--) {
                out("unov8_.type.release(seq_types[" + OUString::number(i) + "]);\n");
            }
            out("}\n");
        }
    }
    out("return obj;\n"
        "}\n");

    has_unov8 = false;
    out("struct " + cStructName(name) + " from_v8_" + cName(name)
        + "(v8::Isolate *isolate, v8::Local<v8::Value> val) {\n");
    out("struct " + cStructName(name) + " result;\n");
    if (!base.isEmpty()) {
        out("result.base = from_v8_" + cName(base) + "(isolate, val);\n");
    }
    out(R"(if (!val->IsObject()) {
            convert::ThrowTypeError(isolate, "Attempted to convert a non-object into a struct");
            return result;
        }
    )");
    out("v8::Local<v8::Object> obj = v8::Local<v8::Object>::Cast(val);\n");
    out("v8::Local<v8::Value> v8val;\n");
    for (auto& m : entity->getDirectMembers()) {
        out("if (!obj->Get(isolate->GetCurrentContext(), v8::String::NewFromUtf8Literal(isolate, \""
            + m.name
            + "\")).ToLocal(&v8val)) convert::ThrowTypeError(isolate, \"object is missing property "
              "'"
            + m.name + "' for " + simplifyNamespace(name) + " \");\n");
        OUString nucl(decomposeType(resolveTypedef(m.type), &rank, &args, &isEntity));
        if (rank > 0) {
            // TODO: add proper support for rank > 1
            if (!has_unov8 && rank == 1) {
                out("auto& unov8_ = electron::office::OfficeClient::GetUnoV8();\n");
                has_unov8 = true;
            }
            if (rank > 1) {
                out("convert::ThrowTypeError(isolate, \"TODO: Converting to a nested array "
                    "unsupported\");\n");
            } else if (isEntity) {
                switch (entities_[nucl]->entity->getSort()) {
                    case unoidl::Entity::SORT_INTERFACE_TYPE:
                        out("{\n");
                        out("typelib_TypeDescriptionReference* el_type_ref_ = "
                            "unov8_.type.interfaceTypeFromId(convert::hash(\""
                            + simplifyNamespace(nucl)
                            + "\"));"
                              "\n");
                        out("result." + m.name
                            + " = convert::Sequence(isolate, v8val, el_type_ref_);\n");
                        out("}\n");
                        break;
                    case unoidl::Entity::SORT_ENUM_TYPE:
                        out("{\n");
                        out("typelib_TypeDescriptionReference* el_type_ref_ = "
                            "unov8_.type.enumType(convert::hash(\""
                            + simplifyNamespace(nucl) + "\"));\n");
                        out("result." + m.name
                            + " = convert::Sequence(isolate, v8val, el_type_ref_);\n");
                        out("}\n");
                        break;
                    case unoidl::Entity::SORT_PLAIN_STRUCT_TYPE:
                        out("{\n");
                        out("typelib_TypeDescriptionReference* el_type_ref_ = "
                            "unov8_.type.structType(convert::hash(\""
                            + simplifyNamespace(nucl)
                            + "\"));"
                              "\n");
                        out("result." + m.name
                            + " = convert::Sequence(isolate, v8val, el_type_ref_);\n");
                        out("}\n");
                        break;
                    default:
                        break;
                }
            } else {
                out("{\n");
                out("typelib_TypeDescriptionReference* el_type_ref_ = "
                    "*unov8_.type.getByTypeClass(typelib_"
                    "TypeClass_"
                    + translateSimpleTypeAsTypeClassPostfix(nucl) + ");\n");
                out("result." + m.name + " = convert::Sequence(isolate, v8val, el_type_ref_);\n");
                out("}\n");
            }
        } else if (isEntity) {
            switch (entities_[nucl]->entity->getSort()) {
                case unoidl::Entity::SORT_INTERFACE_TYPE:
                    out("{\n");
                    out("unoclass::" + cName(nucl) + "* ptr;\n");
                    out("if (!gin::ConvertFromV8(isolate, v8val, &ptr)) "
                        "convert::ThrowTypeError(isolate, "
                        "\"expected "
                        + simplifyNamespace(nucl) + " for property '" + m.name + "'\");\n");
                    out("result." + m.name + " = static_cast<void*>(ptr->Get());\n");
                    out("}\n");
                    break;
                case unoidl::Entity::SORT_ENUM_TYPE:
                    out("result." + m.name + " = ULong(isolate, v8val);\n");
                    break;
                case unoidl::Entity::SORT_PLAIN_STRUCT_TYPE:
                    out("result." + m.name + " = from_v8_" + cName(nucl) + "(isolate, v8val);\n");
                    break;
                default:
                    break;
            }
        } else if (nucl == "any") {
            out("convert::Any(isolate, v8val, &result." + m.name + ");\n");
        } else if (nucl == "type") {
            out("{\n");
            out("unoclass::Type* ptr;\n");
            out("if (!gin::ConvertFromV8(isolate, v8val, &ptr)) convert::ThrowTypeError(isolate, "
                "\"expected Type class for property '"
                + m.name + "'\");\n");
            out("result." + m.name + " = ptr->Get();\n");
            out("}\n");
        } else {
            out("result." + m.name + " = convert::" + translateSimpleTypeHandler(nucl)
                + "(isolate, v8val);\n");
        }
    }
    out("return result;\n"
        "}\n");
}

void V8Writer::writePolymorphicStruct(
    OUString const& name, rtl::Reference<unoidl::PolymorphicStructTypeTemplateEntity> entity) {
    // no-op
    (void)name;
    (void)entity;
}

void V8Writer::writeException(OUString const& name,
                              rtl::Reference<unoidl::ExceptionTypeEntity> entity) {
    // no-op
    (void)name;
    (void)entity;
}

void V8Writer::writeInterfaceMethodBuilder(OUString const& name,
                                           unoidl::InterfaceTypeEntity* entity,
                                           std::unordered_set<int>& declared) {
    for (auto& i : entity->getDirectMethods()) {
        if (shouldSkipMethod(i) || declared.find(i.name.hashCode()) != declared.end())
            continue;
        declared.emplace(i.name.hashCode());
        out("\n.SetMethod(\"" + i.name + "\", &" + cName(name) + "::" + i.name + ")");
    }
    for (auto& i : entity->getDirectMandatoryBases()) {
        // acquire/release are handled on object create/destroy
        if (i.name == "com.sun.star.uno.XInterface")
            continue;

        auto* base_ent = static_cast<unoidl::InterfaceTypeEntity*>(entities_[i.name]->entity.get());
        writeInterfaceMethodBuilder(name, base_ent, declared);
    }
}

void V8Writer::writeMethodReturn(OUString const& type) {
    std::size_t rank;
    std::vector<OUString> args;
    bool isEntity;
    OUString nucl(decomposeType(type, &rank, &args, &isEntity));

    if (rank > 0) {
        out("typelib_TypeDescriptionReference* base_type = ");
        if (isEntity) {
            switch (entities_[nucl]->entity->getSort()) {
                case unoidl::Entity::SORT_INTERFACE_TYPE:
                    out("unov8_.type.interfaceTypeFromId(convert::hash(\"" + simplifyNamespace(nucl)
                        + "\"))");
                    break;
                case unoidl::Entity::SORT_ENUM_TYPE:
                    out("unov8_.type.enumType(convert::hash(\"" + simplifyNamespace(nucl) + "\"))");
                    break;
                case unoidl::Entity::SORT_PLAIN_STRUCT_TYPE:
                    out("unov8_.type.structType(convert::hash(\"" + simplifyNamespace(nucl)
                        + "\"))");
                    break;
                default:
                    break;
            }
        } else {
            out("*unov8_.type.getByTypeClass(typelib_TypeClass_"
                + translateSimpleTypeAsTypeClassPostfix(nucl) + ")");
        }
        out(";\n");

        out("typelib_TypeDescriptionReference* seq_types[" + OUString::number(rank) + "];\n");
        for (size_t i = 0; i < rank; i++) {
            out("seq_types[" + OUString::number(i) + "] = unov8_.type.sequenceType(");
            if (i == 0)
                out("base_type");
            else
                out("seq_types[" + OUString::number(i - 1) + "]");
            out(");\n");
        }
    }

    out("v8::Local<v8::Value> v8_result = ");
    if (rank > 0) {
        out("convert::Sequence(isolate, result, seq_types[" + OUString::number(rank - 1) + "])");
    } else if (isEntity) {
        switch (entities_[nucl]->entity->getSort()) {
            case unoidl::Entity::SORT_INTERFACE_TYPE:
                out("unoclass::" + cName(nucl) + "::Create(isolate, result).ToV8()");
                break;
            case unoidl::Entity::SORT_ENUM_TYPE:
                out("convert::ULong(isolate, result)");
                break;
            case unoidl::Entity::SORT_PLAIN_STRUCT_TYPE:
                out("convert::to_v8_" + cName(nucl) + "(isolate, result)");
                break;
            default:
                out("/* TYPE?? " + OUString::number(entities_[nucl]->entity->getSort()) + " */");
                break;
        }
    } else if (nucl == "any") {
        out("convert::Any(isolate, &result)");
    } else if (nucl == "type") {
        out("unoclass::Type::Create(isolate, result).ToV8()");
    } else if (nucl == "void") {
        out("v8::Null(isolate)");
    } else {
        out("convert::" + translateSimpleTypeHandler(nucl) + "(isolate, result)");
    }
    out(";\n");

    if (rank > 0) {
        for (int i = (int)rank - 1; i >= 0; i--) {
            out("unov8_.type.release(seq_types[" + OUString::number(i) + "]);\n");
        }
    }

    out("return v8_result;\n");
}

void V8Writer::writeInterfaceMethods(OUString const& name, OUString const& className,
                                     unoidl::InterfaceTypeEntity* entity,
                                     std::unordered_set<int>& declared) {
    for (auto& i : entity->getDirectMethods()) {
        if (shouldSkipMethod(i) || declared.find(i.name.hashCode()) != declared.end())
            continue;
        declared.emplace(i.name.hashCode());

        if (i.returnType == "void")
            out("void ");
        else
            out("v8::Local<v8::Value> ");

        out(cName(className) + "::" + i.name + "(v8::Isolate* isolate");
        for (auto& a : i.parameters) {
            out(", v8::Local<v8::Value> v8_" + a.name);
        }
        out(") {\n");
        out("rtl_uString* err;\n");
        out("auto& unov8_ = electron::office::OfficeClient::GetUnoV8();\n");

        if (i.returnType != "void") {
            writeType(i.returnType);
            out(" result{};\n");
        }

        writeMethodParamsConstructors(i);

        out("unov8_.methods." + cName(name) + "_" + i.name + "(");
        out("inst_,");
        if (i.returnType != "void")
            out("&result,");
        out("&err");

        for (auto& a : i.parameters) {
            out(", " + a.name);
        }

        out(");\n");

        writeMethodParamsDestructors(i);

        out("MaybeThrowErr(isolate, err);\n");
        if (i.returnType != "void") {
            writeMethodReturn(resolveTypedef(i.returnType));
        }
        out("}\n");
    }
    for (auto& i : entity->getDirectMandatoryBases()) {
        // acquire/release are handled on object create/destroy
        if (i.name == "com.sun.star.uno.XInterface")
            continue;

        auto* base_ent = static_cast<unoidl::InterfaceTypeEntity*>(entities_[i.name]->entity.get());
        writeInterfaceMethods(i.name, className, base_ent, declared);
    }
}

void V8Writer::writeInterface(OUString const& name,
                              rtl::Reference<unoidl::InterfaceTypeEntity> entity) {
    out("gin::Handle<" + cName(name) + "> " + cName(name)
        + "::Create(v8::Isolate* isolate, void *inst) {\n");
    out("auto *t = new " + cName(name) + "();\n");
    out("auto& unov8_ = electron::office::OfficeClient::GetUnoV8();\n");
    out("auto *type_ref = unov8_.type.interfaceTypeFromId(convert::hash(\""
        + simplifyNamespace(name) + "\"));\n");
    out("void *new_inst = unov8_.interface.queryInterface(inst, type_ref);\n");
    out("t->inst_ = new_inst;\n");
    out("unov8_.interface.acquire(new_inst);\n");
    out("return CreateHandle(isolate, t);\n");
    out("};\n");

    out("gin::ObjectTemplateBuilder " + cName(name)
        + "::GetObjectTemplateBuilder(v8::Isolate* isolate) {");
    out(R"(
  gin::PerIsolateData* data = gin::PerIsolateData::From(isolate);
  v8::Local<v8::FunctionTemplate> constructor = data->GetFunctionTemplate(&kWrapperInfo);
  if (constructor.IsEmpty()) {
    constructor = v8::FunctionTemplate::New(isolate);
    constructor->SetClassName(gin::StringToV8(isolate, GetTypeName()));
    constructor->ReadOnlyPrototype();
    data->SetFunctionTemplate(&kWrapperInfo, constructor);
  }
  return gin::ObjectTemplateBuilder(isolate, GetTypeName(), constructor->InstanceTemplate()))");
    std::unordered_set<int> declared{};
    writeInterfaceMethodBuilder(name, entity.get(), declared);
    out("\n.SetMethod(\"as\", &" + cName(name) + "::As)");

    out(";\n"
        "}\n");

    declared.clear();
    writeInterfaceMethods(name, name, entity.get(), declared);

    out("v8::Local<v8::Value> " + cName(name) + "::As(v8::Isolate* isolate, std::string typeName)");
    out(R"({
    return convert::As(isolate, inst_, typeName);
}
)");

    out(cName(name) + "::~" + cName(name)
        + "() { electron::office::OfficeClient::GetUnoV8().interface.release(inst_); }\n");
}

void V8Writer::writeTypedef(OUString const& name, rtl::Reference<unoidl::TypedefEntity> entity) {
    // no-op
    (void)name;
    (void)entity;
}

void V8Writer::writeConstantGroup(OUString const& name,
                                  rtl::Reference<unoidl::ConstantGroupEntity> entity) {
    out("v8::Local<v8::Object> init_" + cName(name)
        + "(v8::Isolate* isolate) {\n"
          "v8::Local<v8::Object> result = v8::Object::New(isolate);\n");
    for (auto& i : entity->getMembers()) {
        out("result->DefineOwnProperty(isolate->GetCurrentContext(), "
            "v8::String::NewFromUtf8Literal(isolate, \""
            + i.name + "\"), ");
        switch (i.value.type) {
            case unoidl::ConstantValue::TYPE_BOOLEAN:
                out("v8::Boolean::New(isolate, ");
                if (i.value.booleanValue)
                    out("true");
                else
                    out("false");
                out(")");
                break;
            case unoidl::ConstantValue::TYPE_BYTE:
                out("v8::Integer::New(isolate, (sal_Int8)" + OUString::number(i.value.byteValue)
                    + ")");
                break;
            case unoidl::ConstantValue::TYPE_SHORT:
                out("v8::Integer::New(isolate, (sal_Int16)" + OUString::number(i.value.byteValue)
                    + ")");
                break;
            case unoidl::ConstantValue::TYPE_LONG:
                out("v8::Integer::New(isolate, ");
                if (i.value.longValue == SAL_MIN_INT32) {
                    out("SAL_MIN_INT32");
                } else {
                    out("(sal_Int32)" + OUString::number(i.value.longValue));
                }
                out(")");
                break;
            case unoidl::ConstantValue::TYPE_UNSIGNED_SHORT:
                out("v8::Integer::NewFromUnsigned(isolate, (sal_uInt16)"
                    + OUString::number(i.value.unsignedShortValue) + ")");
                break;
            case unoidl::ConstantValue::TYPE_UNSIGNED_LONG:
                out("v8::Integer::NewFromUnsigned(isolate, (sal_uInt32)"
                    + OUString::number(i.value.unsignedShortValue) + ")");
                break;
            case unoidl::ConstantValue::TYPE_FLOAT:
                out("v8::Number::New(isolate, (float)" + OUString::number(i.value.floatValue)
                    + ")");
                break;
            case unoidl::ConstantValue::TYPE_DOUBLE:
                out("v8::Number::New(isolate, (double)" + OUString::number(i.value.doubleValue)
                    + ")");
                break;
            case unoidl::ConstantValue::TYPE_HYPER:
                out("v8::BigInt::New(isolate, ");
                if (i.value.hyperValue == SAL_MIN_INT64) {
                    out("SAL_MIN_INT64");
                } else {
                    out("(sal_Int64) SAL_CONST_INT64(" + OUString::number(i.value.hyperValue)
                        + ")");
                }
                out(")");
                break;
            case unoidl::ConstantValue::TYPE_UNSIGNED_HYPER:
                out("v8::BigInt::NewFromUnsigned(isolate, ");
                out("SAL_CONST_UINT64(" + OUString::number(i.value.unsignedHyperValue) + ")");
                out(")");
                break;
        }
        out(", v8::ReadOnly).Check();\n");
    }
    out("return result;\n");
    out("}\n");
}

void V8Writer::writeSingleInterfaceService(
    OUString const& name, rtl::Reference<unoidl::SingleInterfaceBasedServiceEntity> entity) {
    // no-op
    (void)name;
    (void)entity;
}

void V8Writer::writeAccumulationService(
    OUString const& name, rtl::Reference<unoidl::AccumulationBasedServiceEntity> entity) {
    // no-op
    (void)name;
    (void)entity;
}

void V8Writer::writeInterfaceSingleton(
    OUString const& name, rtl::Reference<unoidl::InterfaceBasedSingletonEntity> entity) {
    // no-op
    (void)name;
    (void)entity;
}

void V8Writer::writeServiceSingleton(OUString const& name,
                                     rtl::Reference<unoidl::ServiceBasedSingletonEntity> entity) {
    // no-op
    (void)name;
    (void)entity;
}

void V8Writer::writeBuildFile() {
    createEntityFile("BUILD", ".gn");
    out(R"(
import("//v8/gni/v8.gni")

config("libreoffice_lib_config") {
  include_dirs = [ "../include", "." ]
  defines = [ "LOK_USE_UNSTABLE_API", "SAL_NO_EXCEPTIONS" ]

  # mostly ported from libreoffice-core/odk/settings/settings.mk
  if (is_win) {
    defines += [
      "CPPU_ENV=mscx",
      "WNT",
      "WIN32"
    ]
  } else {
    defines += [
      "CPPU_ENV=gcc3",
      "UNX"
    ]

    if (is_mac) {
      defines += [ "MACOSX" ]
    }
    if (is_linux) {
      defines += [ "LINUX" ]
    }
  }
}

source_set("unov8") {
  sources = [ "unov8.cxx" ]
  configs += [ ":libreoffice_lib_config" ]
  deps = [
      "//gin"
  ]

  public_deps = [
      "//v8"
  ]
}
)");
    close();
}

void V8Writer::writeMethodParamsConstructors(const unoidl::InterfaceTypeEntity::Method& method) {
    std::size_t rank;
    std::vector<OUString> args;
    bool isEntity;

    for (auto& a : method.parameters) {
        writeType(a.type);
        out(" " + a.name + "{};\n");
        OUString nucl(decomposeType(resolveTypedef(a.type), &rank, &args, &isEntity));
        if (rank > 0) {
            // TODO: add proper support for rank > 1
            if (rank > 1) {
                out("convert::ThrowTypeError(isolate, \"TODO: Converting to a nested array "
                    "unsupported\");\n");
            } else if (nucl == "com.sun.star.beans.PropertyValue") {
                out(a.name + " = convert::PropertyValueSequence(isolate, v8_" + a.name + ");\n");
            } else if (isEntity) {
                // special exception for PropertyValue sequences, read it as an object

                switch (entities_[nucl]->entity->getSort()) {
                    case unoidl::Entity::SORT_INTERFACE_TYPE:
                        out("{\n");
                        out("typelib_TypeDescriptionReference* el_type_ref_ = "
                            "unov8_.type.interfaceTypeFromId(convert::hash(\""
                            + simplifyNamespace(nucl)
                            + "\"));"
                              "\n");
                        out(a.name + " = convert::Sequence(isolate, v8_" + a.name
                            + ", el_type_ref_);\n");
                        out("}\n");
                        break;
                    case unoidl::Entity::SORT_ENUM_TYPE:
                        out("{\n");
                        out("typelib_TypeDescriptionReference* el_type_ref_ = "
                            "unov8_.type.enumType(convert::hash(\""
                            + simplifyNamespace(nucl) + "\"));\n");
                        out(a.name + " = convert::Sequence(isolate, v8_" + a.name
                            + ", el_type_ref_);\n");
                        out("}\n");
                        break;
                    case unoidl::Entity::SORT_PLAIN_STRUCT_TYPE:
                        out("{\n");
                        out("typelib_TypeDescriptionReference* el_type_ref_ = "
                            "unov8_.type.structType(convert::hash(\""
                            + simplifyNamespace(nucl)
                            + "\"));"
                              "\n");
                        out(a.name + " = convert::Sequence(isolate, v8_" + a.name
                            + ", el_type_ref_);\n");
                        out("}\n");
                        break;
                    default:
                        break;
                }
            } else {
                out("{\n");
                out("typelib_TypeDescriptionReference* el_type_ref_ = "
                    "*electron::office::OfficeClient::GetUnoV8().type.getByTypeClass(typelib_"
                    "TypeClass_"
                    + translateSimpleTypeAsTypeClassPostfix(nucl) + ");\n");
                out(a.name + " = convert::Sequence(isolate, v8_" + a.name + ", el_type_ref_);\n");
                out("}\n");
            }
        } else if (isEntity) {
            switch (entities_[nucl]->entity->getSort()) {
                case unoidl::Entity::SORT_INTERFACE_TYPE:
                    out("{\n");
                    out("unoclass::" + cName(nucl) + "* ptr;\n");
                    out("if (!gin::ConvertFromV8(isolate, v8_" + a.name
                        + ", &ptr)) "
                          "convert::ThrowTypeError(isolate, "
                          "\"expected "
                        + simplifyNamespace(nucl) + " for property '" + a.name + "'\");\n");
                    out(a.name + " = static_cast<void*>(ptr->Get());\n");
                    out("}\n");
                    break;
                case unoidl::Entity::SORT_ENUM_TYPE:
                    out(a.name + " = convert::ULong(isolate, v8_" + a.name + ");\n");
                    break;
                case unoidl::Entity::SORT_PLAIN_STRUCT_TYPE:
                    out(a.name + " = convert::from_v8_" + cName(nucl) + "(isolate, v8_" + a.name
                        + ");\n");
                    break;
                default:
                    break;
            }
        } else if (nucl == "any") {
            out("convert::Any(isolate, v8_" + a.name + ", &" + a.name + ");\n");
        } else if (nucl == "type") {
            out("{\n");
            out("unoclass::Type* ptr;\n");
            out("if (!gin::ConvertFromV8(isolate, v8_" + a.name
                + ", &ptr)) convert::ThrowTypeError(isolate, "
                  "\"expected Type class for property '"
                + a.name + "'\");\n");
            out(a.name + " = ptr->Get();\n");
            out("}\n");
        } else {
            out(a.name + " = convert::" + translateSimpleTypeHandler(nucl) + "(isolate, v8_"
                + a.name + ");\n");
        }
    }
}

void V8Writer::writeMethodParamsDestructors(const unoidl::InterfaceTypeEntity::Method& method) {
    for (auto& a : method.parameters) {
        OUString type = resolveTypedef(a.type);
        if (type == "string") {
            out("unov8_.rtl.uString_release(" + a.name + ");\n");
        }
    }
}
}
